# Task 3: Multi-threading + Networking
## Мобильное приложение для просмотра характеристик персонажей мультсериала Rick&Morty 

### Структура приложения:

Экраны: 
- Список персонажей 
- Карточка персонажа 

Модели данных:
- Карточка персонажа 
- Местоположение 
- Эпизод

Данные достаточно хранить в оперативной памяти. 

### Описание  API:

Для разработки следует использовать данное задание и документацию https://rickandmortyapi.com/documentation/ 

Протокол HTTP, авторизация не требуется, данные возвращаются в формате JSON. 

Можно использовать кеширование запросов URLSessionTask 

Не обязательно парсить все поля данных, достаточно тех, что реально используются в UI 

### Требования к технологиям:

Для разработки следует использовать native средства: 
- GCD 
- OperationQueue 
- URLSession 
- URLSessionTasks 

Версия XCode 12.x 

## Экран списка персонажей:

![image](https://user-images.githubusercontent.com/85530945/125115723-64a35580-e0f4-11eb-9276-e3ad50b0f1ad.png)

### Дизайн

Следует использовать стандартные UI компоненты. 
Главным элементом вляется TableView со списком персонажей и NavigationBar с названием экрана 
Схематичная расстановка компонент изображена выше. 
Отступы на усмотрение разработчика 

Каждая ячейка списка должны содержать:  
- картинку персонажа,  
- имя персонажа,  
- индикатор перехода справа 

### Переходы

При нажатии на ячейку персонажа в списке должен произойти переход на экран «Карточка персонажа».
Для перехода можно использовать UINavigationController push 

### Пользовательские сценарии и критерии приемки 

1. Загрузка списка (Как пользователь я хочу иметь возможность загрузить список всех персонажей и управлять интерфейсом, не дожидаясь окончания загрузки)
- Пользователь запускает приложение 
- Приложение загружает и отображает первую страницу списка персонажей 
- Приложение параллельно загружает остальные страницы по порядку по 3 страницы одновременно и обновляет список.  
    Например:  
    * Загрузка страниц 2-3-4 выполняется параллельно 
    * Загруженные персонажи в добавляются в TableView в том порядке в каком они шли на страницах (сначала персонажий 2й страницы) 
    * Загрузка страниц 5-6-7 выполняется параллельно 
    * итд 
- Загрузка и отображение изображений каждого персонажа должна происходить только для видимых на экране ячеек 

2. Прокрутка списка (Как пользователь я хочу иметь возможность прокручивать список персонажей во время загрузки без сброса текущей позиции)
- Идет загрузка остальных страниц списка персонажей 
- Пользователь прокручивает список (возможно до самого конца) 
- Приложение добавило новых персонажей в список 
- Пользователь может продолжить прокручивать список вниз до новых загруженных персонажей 

3. Плавность(*) 
Задание со звездочкой.  
Будет плюсом если во время загрузки позиция, на которой остановился пользователь при прокрутке, не будет сбрасываться в начало 
- Идет загрузка остальных страниц списка персонажей 
- Пользователь прокрутил список до середины список  
- Приложение добавило новых персонажей в список 
- Пользователь продолжает прокручивать список с того же места 

### Техническое решение

1. Используйте запрос GET https://rickandmortyapi.com/api/character для загрузки первой страницы списка с персонажами 

Ответ:

```json
{ 

  "info": { 

    "count": 671, - число персонажей на странице 

    "pages": 34, - число страниц 

  }, 

  "results": [ 

    { 

      "id": 1, 

      "name": "Rick Sanchez", - Имя персонажа 

      "status": "Alive", 

      "species": "Human", 

      "type": "", 

      "gender": "Male", 

      "origin": { 

        "name": "Earth", 

        "url": "https://rickandmortyapi.com/api/location/1" 

      }, 

      "location": { 

        "name": "Earth", 

        "url": "https://rickandmortyapi.com/api/location/20" 

      }, 

      "image": "https://rickandmortyapi.com/api/character/avatar/1.jpeg", - Картинка персонажа 

      "episode": [ 

        "https://rickandmortyapi.com/api/episode/1", 

        "https://rickandmortyapi.com/api/episode/2", 

        // ... 

      ], 

      "url": "https://rickandmortyapi.com/api/character/1", 

      "created": "2017-11-04T18:48:46.250Z" 

    }, 

  //…. 

  ] 

} 
```

2. Используйте запрос GET https://rickandmortyapi.com/api/character/?page=XX для загрузки конкретной страницы, где XX – номер страницы в формате Int. 
Максимальное число страниц можно получить из первого запроса 


## Экран карточки персонажа:

![image](https://user-images.githubusercontent.com/85530945/125117663-38d59f00-e0f7-11eb-878d-9f7f860f4057.png)


### Дизайн

Следует использовать стандартные UI компоненты. 
Для отображения списка эпизодов можно использовать UITextView, каждый эпизод с новой строки 
Схематичная расстановка компонент изображена выше. 
Отступы на усмотрение разработчика 
Информация о местоположении тоже можно разместить в UITextView 

### Переходы

По кнопке «назад» в NavigationBar можно вернуться к списку персонажей.
Дизайн кнопки назад можно сделать любым, например по умолчанию  

### Пользовательские сценарии и критерии приемки 

1. Загрузка карточки (Как пользователь при заходе на экран я хочу иметь полностью загруженную карточку персонажа. Карточка должна включать список эпизодов и детальное местоположение пользователя)
* Пользователь перешел на экран карточки эпизода 
* Приложение отображает UIActivityIndicator пока все данные не загрузятся 
* Приложение делает запрос за карточкой персонажа 
* После получения карточки персонажа приложение запрашивает эпизоды и местоположение, иконку персонажа. Все запросы параллельны. 
* После загрузки всех данных, приложение скрывает UIActivityIndicator и отображает: 
    * Картинка персонажа 
    * Имя – в NavigationBar тоже 
    * Пол  
    * Статус 
    * Вид 
    * Местоположение 
    * Список эпизодов 

Каждый элемент списка эпизодов отображает 
* Название эпизода 
* Номер эпизода 
* Дату выхода как прислал сервер 

Местоположение включает в себя поля 
* Название 
* Тип 

### Техническое решение

1. Используйте запрос GET https://rickandmortyapi.com/api/character/XX для загрузки конкретного персонажа, где XX – ID персонажа в формате Int. 

Ответ:

```json
 {
 
  "id": 2, 

  "name": "Morty Smith", -  имя 

  "status": "Alive", - статус 

  "species": "Human", - вид 

  "type": "", 

  "gender": "Male", - пол 

  "origin": { 

    "name": "Earth", 

    "url": "https://rickandmortyapi.com/api/location/1" 

  }, 

  "location": { 

    "name": "Earth", 

    "url": https://rickandmortyapi.com/api/location/20 - для запроса местоположения 

  }, 

  "image": "https://rickandmortyapi.com/api/character/avatar/2.jpeg", - Картинка персонажа 

  "episode": [ 

    "https://rickandmortyapi.com/api/episode/1", - для запроса эпизода 

    "https://rickandmortyapi.com/api/episode/2", - для запроса эпизода 

    // ... 

  ], 

  "url": "https://rickandmortyapi.com/api/character/2", 

  "created": "2017-11-04T18:50:21.651Z" 

} 
```

2. Используйте ссылку из поля “location” чтобы сделать  GET запрос на местоположение персонажа.

Ответ:

```json
{ 

  "id": 3, 

  "name": "Citadel of Ricks", - название 

  "type": "Space station", - тип 

  "dimension": "unknown", 

  "residents": [ 

    "https://rickandmortyapi.com/api/character/8", 

    "https://rickandmortyapi.com/api/character/14", 

    // ... 

  ], 

  "url": "https://rickandmortyapi.com/api/location/3", 

  "created": "2017-11-10T13:08:13.191Z" 

} 
```

3. Используйте ссылки из поля “episode” чтобы сделать  GET запрос на список эпизодов где участвовал персонаж.

Ответ:

```json
{ 

  "id": 28, 

  "name": "The Ricklantis Mixup", - название эпизода 

  "air_date": "September 10, 2017", - дата выхода 

  "episode": "S03E07", - номер эпизода 

  "characters": [ 

    "https://rickandmortyapi.com/api/character/1", 

    "https://rickandmortyapi.com/api/character/2", 

    // ... 

  ], 

  "url": "https://rickandmortyapi.com/api/episode/28", 

  "created": "2017-11-10T12:56:36.618Z" 

} 
```

Порядок запросов: 
* Запрос персонажа 
* Запрос место положения и запросы эпизодов выполняются параллельно


### Дополнительные критерии приемки
* Поскольку был пройдена лекция по архитектурам, рекомендуется работу с данными, сетью, не выполнять в UI слое.  
* Все что может заблокировать работу UI следует выполнять в отдельных потоках или очередях. 
